<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	string ClassName;
	string csClass;
	string cppClass;
	string cppVector = null;

	outputClass(manager, "Int", "int", "int", new VectorParms());
	outputClass(manager, "Byte", "byte", "unsigned char", new VectorParms());

	var pointParms= new VectorParms
	{
		Namespaces = new[]{"System.Numerics", "PclSharp.Struct"},
		Includes = new[]{"pcl\\point_types.h"},
		CppNamespaces = new[]{"pcl"}
	};
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ", pointParms);
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA", pointParms);
	outputClass(manager, "Normal", "Normal", "Normal", pointParms);


	manager.Process(true);
#>
<#+
void outputClass(Manager manager, string ClassName, string csClass, string cppClass, VectorParms parms) 
{
	var classname = ClassName.ToLower();
	var classFunc = "std_vector_" + classname;

	var cppVector = parms.cppVector;

	if (cppVector== null)	
	 cppVector = "vector<"+cppClass+">";

	manager.StartNewFile("VectorOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppVector);
	i.Var("cppClass", cppClass);
	i.Var("cppVector", cppVector);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
<#= string.Join("", parms.Namespaces.Select(s => "using " + s + ";\r\n")) #>

namespace PclSharp.Std
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_count", "int count") #>
		<#= i.Delete() #>
		<#= i.FuncI("at", " UIntPtr idx, ref csClass value") #>
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("void", "resize", "int size") #>
		<#= i.FuncI("add", "csClass value") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("insert", "IntPtr idx, csClass value") #>
	}

	public unsafe class VectorOf<#= ClassName #> : IDisposable, IList<<#=csClass#>>
	{	
		protected IntPtr _ptr;

		public IntPtr Ptr => _ptr;

		public int Count => (int)<#=i.InvokeI("size")#>;
		public IntPtr Data => <#=i.InvokeI("data")#>;
		public <#=csClass#>* DataU => (<#=csClass#>*)Data;

		public bool IsReadOnly => false;

		public VectorOf<#= ClassName #>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		/// <summary>
        /// construct as a copy of the list
        /// </summary>
        /// <param name="list"></param>
		public VectorOf<#= ClassName #>(List<<#=csClass#>> list)
        {
            var arr = list.ToArray();
            _ptr = <#=i.Invoke("ctor_count", "arr.Length")#>;
            
            var dptr = (<#=csClass#>*)Data;
            for(var i = 0; i < arr.Length; i++)
                dptr[i] = arr[i];
        }

		internal VectorOf<#=ClassName#>(IntPtr ptr)
		{
			_ptr = ptr;
		}

		public void At(int idx, ref <#=csClass#> value)
		{
			<#=i.InvokeI("at", "(UIntPtr)idx, ref value")#>;
		}

		public <#=csClass#> this[int idx]
        {
            get { return DataU[idx]; }
			set { DataU[idx] = value; }
		}

		public void Resize(int size)
			=> <#=i.InvokeI("resize", "size")#>;

		public void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "value")#>;

		public bool Contains(<#=csClass#> value)
		{ throw new NotImplementedException(); }

		public void CopyTo(<#=csClass#>[] arr, int idx)
		{
            fixed (<#=csClass#>* aptr = arr)
            {
                Unsafe.CopyBlockUnaligned(aptr, DataU, (uint)(sizeof(<#=csClass#>) * Count));
            }
		}

		public <#=csClass#>[] ToArray()
		{
			var arr = new <#=csClass#>[Count];
            fixed (<#=csClass#>* aptr = arr)
            {
                Unsafe.CopyBlockUnaligned(aptr, DataU, (uint)(sizeof(<#=csClass#>) * arr.Length));
            }

			return arr;
		}

		public void Clear() => <#=i.InvokeI("clear")#>;

		public int IndexOf(<#=csClass#> value) 
		{ throw new NotImplementedException(); }

		public void Insert(int index, <#=csClass#> item)
			=> <#=i.InvokeI("insert", "(IntPtr)index, item")#>;

		public bool Remove(<#=csClass#> item)
		{ throw new NotImplementedException(); }

		public void RemoveAt(int index)
		{ throw new NotImplementedException(); }

		public IEnumerator<<#=csClass#>> GetEnumerator()
			=> ((IEnumerable<<#=csClass#>>)ToArray()).GetEnumerator();

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> GetEnumerator();

		public void Dispose()
		{
			<#= i.DeleteI() #>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\VectorOf"+ClassName+".generated.h");
#>
// Code generated by a template
#pragma once
#include "..\export.h"
#include <vector>
<#= string.Join("", parms.Includes.Select(s => "#include \"" + s + "\"\r\n")) #>

using namespace std;
<#= string.Join("", parms.CppNamespaces.Select(s => "using namespace " + s + ";\r\n")) #>

typedef <#= cppVector #> vectorType;

#ifdef __cplusplus  
extern "C" {  
#endif

<#= i.Export("vectorType*", "ctor", "") #>
{
	return new <#=cppVector#>();
}

<#= i.Export("vectorType*", "ctor_count", "int count") #>
{
	return new <#=cppVector#>(count);
}

<#=i.Export("void", "delete", "cppVector** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "at", "size_t idx, cppClass* value")#>
{
	value = &ptr->at(idx);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("void", "resize", "int32_t size")#>
{
	ptr->resize(size);
}

<#=i.ExportI("void", "add", "cppClass value")#>
{
	ptr->push_back(value);
}

<#=i.ExportI("void", "insert", "ptrdiff_t index, cppClass value")#>
{
	ptr->insert(ptr->begin()+index, value);
}

<#=i.ExportI("cppClass*", "data", "")#>
{
	return ptr->data();
}

#ifdef __cplusplus  
}
#endif
<#+ manager.EndBlock(false); } #>