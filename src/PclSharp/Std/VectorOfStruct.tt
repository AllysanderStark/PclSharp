<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	string ClassName;
	string csClass;
	string cppClass;
	string cppVector = null;

	outputClass(manager, "Int", "int", "int", new VectorParms());
	outputClass(manager, "Byte", "byte", "unsigned char", new VectorParms());
	outputClass(manager, "XYZ", "Vector3", "PointXYZ", new VectorParms
	{
		Namespaces = new[]{"System.Numerics"},
		Includes = new[]{"pcl\\point_types.h"},
		CppNamespaces = new[]{"pcl"}
	});


	manager.Process(true);
#>
<#+
void outputClass(Manager manager, string ClassName, string csClass, string cppClass, VectorParms parms) 
{
	var classname = ClassName.ToLower();
	var classFunc = "std_vector_" + classname;

	var cppVector = parms.cppVector;

	if (cppVector== null)	
	 cppVector = "vector<"+cppClass+">";

	manager.StartNewFile("VectorOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppVector);
	i.Var("cppClass", cppClass);
	i.Var("cppVector", cppVector);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
<#= string.Join("", parms.Namespaces.Select(s => "using " + s + ";\r\n")) #>

namespace PclSharp.Std
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>
		<#= i.FuncI("at", " UIntPtr idx, ref csClass value") #>
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("add", "csClass value") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("insert", "IntPtr idx, csClass value") #>
	}

	public unsafe class VectorOf<#= ClassName #> : IDisposable, IList<<#=csClass#>>
	{	
		protected IntPtr _ptr;

		public IntPtr Ptr => _ptr;

		public int Count => (int)<#=i.InvokeI("size")#>;
		public IntPtr Data => <#=i.InvokeI("data")#>;
		public <#=csClass#>* DataU => (<#=csClass#>*)Data;

		public bool IsReadOnly => false;

		public VectorOf<#= ClassName #>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		internal VectorOf<#=ClassName#>(IntPtr ptr)
		{
			_ptr = ptr;
		}

		public void At(int idx, ref <#=csClass#> value)
		{
			<#=i.InvokeI("at", "(UIntPtr)idx, ref value")#>;
		}

		public <#=csClass#> this[int idx]
        {
            get { return DataU[idx]; }
			set { DataU[idx] = value; }
		}

		public void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "value")#>;

		public bool Contains(<#=csClass#> value)
		{ throw new NotImplementedException(); }

		public void CopyTo(<#=csClass#>[] arr, int idx)
		{ throw new NotImplementedException(); }

		public void Clear() => <#=i.InvokeI("clear")#>;

		public int IndexOf(<#=csClass#> value) 
		{ throw new NotImplementedException(); }

		public void Insert(int index, <#=csClass#> item)
			=> <#=i.InvokeI("insert", "(IntPtr)index, item")#>;

		public bool Remove(<#=csClass#> item)
		{ throw new NotImplementedException(); }

		public void RemoveAt(int index)
		{ throw new NotImplementedException(); }

		public IEnumerator<<#=csClass#>> GetEnumerator()
		{ throw new NotImplementedException(); }

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> GetEnumerator();

		public void Dispose()
		{
			<#= i.DeleteI() #>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\VectorOf"+ClassName+".generated.h");
#>
// Code generated by a template
#pragma once
#include "..\export.h"
#include <vector>
<#= string.Join("", parms.Includes.Select(s => "#include \"" + s + "\"\r\n")) #>

using namespace std;
<#= string.Join("", parms.CppNamespaces.Select(s => "using namespace " + s + ";\r\n")) #>

typedef <#= cppVector #> vectorType;

#ifdef __cplusplus  
extern "C" {  
#endif

<#= i.Export("vectorType*", "ctor", "") #>
{
	return new <#=cppVector#>();
}

<#=i.Export("void", "delete", "cppVector** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}


<#=i.ExportI("void", "at", "size_t idx, cppClass* value")#>
{
	value = &ptr->at(idx);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("void", "add", "cppClass value")#>
{
	ptr->push_back(value);
}

<#=i.ExportI("void", "insert", "ptrdiff_t index, cppClass value")#>
{
	ptr->insert(ptr->begin()+index, value);
}

<#=i.ExportI("cppClass*", "data", "")#>
{
	return ptr->data();
}

#ifdef __cplusplus  
}
#endif
<#+ manager.EndBlock(false); } #>