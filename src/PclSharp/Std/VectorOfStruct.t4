<#
{
var classname = ClassName.ToLower();
var classFunc = "std_vector_" + classname;
var InvokeFunc = "Invoke." + classFunc;
var @extern = "[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]\r\n		public static extern";

string cppClass;
switch(classname)
{
	case "byte": cppClass = "unsigned char"; break;
	default: cppClass = classname; break;
}
	
var cppVector = "vector<"+cppClass+">";

manager.StartNewFile("VectorOf"+ClassName+".generated.cs");
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace PclSharp.Std
{
	public class VectorOf<#= ClassName #> : IDisposable, IList<<#=classname#>>
	{	
		protected IntPtr _ptr;

		public IntPtr Ptr => _ptr;

		public int Count => (int)<#=InvokeFunc#>_size(_ptr);
		public IntPtr Data => <#=InvokeFunc#>_data(_ptr);

		public bool IsReadOnly => false;

		public VectorOf<#= ClassName #>()
		{
			_ptr = <#= InvokeFunc #>_ctor();
		}

		public void At(int idx, ref <#=classname#> value)
		{
			<#=InvokeFunc #>_at(_ptr, (UIntPtr)idx, ref value);
		}

		public unsafe <#=classname#> this[int idx]
        {
            get { return ((<#=classname#>*)Data)[idx]; }
			set { ((<#=classname#>*)Data)[idx] = value; }
		}

		public void Add(<#=classname#> value)
			=> <#=InvokeFunc#>_add(_ptr, value);

		public bool Contains(<#=classname#> value)
		{ throw new NotImplementedException(); }

		public void CopyTo(<#=classname#>[] arr, int idx)
		{ throw new NotImplementedException(); }

		public void Clear() => <#=InvokeFunc#>_clear(_ptr);

		public int IndexOf(<#=classname#> value) 
		{ throw new NotImplementedException(); }

		public void Insert(int index, <#=classname#> item)
			=> <#=InvokeFunc#>_insert(_ptr, (IntPtr)index, item);

		public bool Remove(<#=classname#> item)
		{ throw new NotImplementedException(); }

		public void RemoveAt(int index)
		{ throw new NotImplementedException(); }

		public IEnumerator<<#=classname#>> GetEnumerator()
		{ throw new NotImplementedException(); }

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> GetEnumerator();

		public void Dispose()
		{
			<#= InvokeFunc #>_delete(ref _ptr);
		}
	}

	public static partial class Invoke
	{
		<#= @extern #> IntPtr <#= classFunc #>_ctor();
		<#= @extern #> void <#= classFunc #>_delete(ref IntPtr ptr);
		<#= @extern #> void <#= classFunc #>_at(IntPtr ptr, UIntPtr idx, ref <#=classname#> value);
		<#= @extern #> UIntPtr <#= classFunc #>_size(IntPtr ptr);
		<#= @extern #> void <#= classFunc #>_clear(IntPtr ptr);
		<#= @extern #> void <#= classFunc #>_add(IntPtr ptr, <#=classname#> value);
		<#= @extern #> IntPtr <#= classFunc #>_data(IntPtr ptr);
		<#= @extern #> void <#= classFunc #>_insert(IntPtr ptr, IntPtr idx, <#=classname#> value);
	}
}
<# 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\VectorOf"+ClassName+".generated.h");
#>
#pragma once
#include "..\export.h"
#include <vector>

using namespace std;

#ifdef __cplusplus  
extern "C" {  
#endif

EXPORT(<#=cppVector#>*) <#=classFunc#>_ctor()
{
	return new <#=cppVector#>();
}

EXPORT(void) <#=classFunc#>_delete(<#=cppVector#>** ptr)
{
	delete ptr;
	ptr = NULL;
}

EXPORT(void) <#=classFunc#>_at(<#=cppVector#>* ptr, size_t idx, <#=cppClass#>* value)
{
	value = &ptr->at(idx);
}

EXPORT(size_t) <#=classFunc#>_size(<#=cppVector#>* ptr)
{
	return ptr->size();
}

EXPORT(void) <#=classFunc#>_clear(<#=cppVector#>* ptr)
{
	ptr->clear();
}

EXPORT(void) <#=classFunc#>_add(<#=cppVector#>* ptr, <#=cppClass#> value)
{
	ptr->push_back(value);
}

EXPORT(void) <#=classFunc#>insert(<#=cppVector#>* ptr, ptrdiff_t index, <#=cppClass#> value)
{
	ptr->insert(ptr->begin()+index, value);
}

EXPORT(<#=cppClass#>*) <#=classFunc#>_data(<#=cppVector#>* ptr)
{
	return ptr->data();
}

#ifdef __cplusplus  
}
#endif  
<# manager.EndBlock(false); } #>