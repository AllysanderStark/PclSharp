<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@include file="Manager.ttinclude"#>
<#@include file="InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "Vector3", "PointXYZ");
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA");
	manager.Process(true);
#>
<#+ void outputClass(Manager manager, string ClassName, string csClass, string cppClass) 
{ 
	var classname = ClassName.ToLower();
	var classFunc = "pointcloud_" + classname;
	
	var cppCloud = "PointCloud<"+cppClass+">";

	manager.StartNewFile("PointCloudOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppCloud);
	i.Var("cppClass", cppClass);
	i.Var("cppCloud", cppCloud);
	i.Var("cppPoint", cppClass);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;

namespace PclSharp
{
	public static partial class Invoke
	{
		//ctor/dctor
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_indices", "IntPtr cloud, IntPtr indices") #>
		<#= i.Delete() #>
		//methods
		<#= i.FuncI("csClass", "at_colrow", "int col, int row") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("add", "csClass value") #>
		//properties
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("uint", "width", "") #>
		<#= i.FuncI("uint", "height", "") #>
		<#= i.FuncI("IntPtr", "points", "") #>
		<#= i.FuncI("bool", "isOrganized", "") #>
	}

	public class PointCloudOf<#=ClassName#> : PointCloud<<#=csClass#>>
	{
		public int Width => (int)<#=i.InvokeI("width")#>;
		public int Height => (int)<#=i.InvokeI("height")#>;
		public int Count => (int)<#=i.InvokeI("size")#>;
		public int Size => Count;
		public bool IsOrganized => <#=i.InvokeI("isOrganized")#>;

		private VectorOf<#=ClassName#> _points;

		public PointCloudOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;

			_points = new VectorOf<#=ClassName#>(<#=i.InvokeI("points")#>);
		}

		public PointCloudOf<#=ClassName#>(PointCloudOf<#=ClassName#> cloud, Std.VectorOfInt indices)
		{
			_ptr = <#=i.Invoke("ctor_indices", "cloud.Ptr, indices.Ptr")#>;

			_points = new VectorOf<#=ClassName#>(<#=i.InvokeI("points")#>);
		}

		public VectorOf<#=ClassName#> Points => _points;

		public override <#=csClass#> At(int col, int row)
			=> <#=i.InvokeI("at_colrow", "col, row")#>;

		public override void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "value")#>;

		public override void Dispose()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\PclSharp.Extern\\pointcloud\\PointCloudOf"+ClassName+".generated.h");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"

using namespace pcl;
using namespace std;

typedef vector<<#=cppClass#>, Eigen::aligned_allocator<<#=cppClass#>>> point_vector;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif  

<#= i.Export("cppCloud*", "ctor", "") #>
{
	return new <#=cppCloud#>();
}

<#=i.Export("cppCloud*", "ctor_indices", "cppCloud* cloud, vector<int>* indices")#>
{
	return new <#=cppCloud#>(*cloud, *indices);
}

<#=i.Export("void", "delete", "cppCloud** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("cppClass", "at_colrow", "int col, int row")#>
{
	return ptr->at(col, row);
}

<#=i.ExportI("void", "add", "cppClass value")#>
{
	ptr->push_back(value);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("uint32_t", "width", "")#>
{
	return ptr->width;
}

<#=i.ExportI("uint32_t", "height", "")#>
{
	return ptr->height;
}

<#=i.ExportI("bool", "isOrganized", "")#>
{
	return ptr->isOrganized();
}

<#=i.ExportI("point_vector*", "points", "")#>
{
	return &ptr->points;
}

#ifdef __cplusplus  
}
#endif  
<#+ manager.EndBlock(false); #>
<#+ } #>