<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@include file="Manager.ttinclude"#>
<#@include file="InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA");
	outputClass(manager, "Normal", "Normal", "Normal");
	manager.Process(true);
#>
<#+ void outputClass(Manager manager, string ClassName, string csClass, string cppClass) 
{ 
	var classname = ClassName.ToLower();
	var classFunc = "pointcloud_" + classname;
	
	var cppCloud = "PointCloud<"+cppClass+">";

	manager.StartNewFile("PointCloudOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppCloud);
	i.Var("cppClass", cppClass);
	i.Var("cppCloud", cppCloud);
	i.Var("cppPoint", cppClass);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using System.Runtime.CompilerServices;

namespace PclSharp
{
	public static partial class Invoke
	{
		//ctor/dctor
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_indices", "IntPtr cloud, IntPtr indices") #>
		<#= i.Func("IntPtr", "ctor_wh", "uint width, uint height") #>
		<#= i.Delete() #>
		//methods
		<#= i.FuncI("unsafe csClass*", "at_colrow", "int col, int row") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("unsafe void", "add", "csClass* value") #>
		//properties
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("uint", "width", "") #>
		<#= i.FuncI("void", "width_set", "uint width") #>
		<#= i.FuncI("uint", "height", "") #>
		<#= i.FuncI("void", "height_set", "uint height") #>
		<#= i.FuncI("IntPtr", "points", "") #>
		[return: MarshalAs(UnmanagedType.Bool)]
		<#= i.FuncI("bool", "isOrganized", "") #>
	}

	public unsafe class PointCloudOf<#=ClassName#> : PointCloud<<#=csClass#>>
	{
		public int Width 
		{
			get { return (int)<#=i.InvokeI("width")#>; }
			set { <#=i.InvokeI("width_set", "(uint)value")#>; }
		}
		public int Height 
		{
			get { return (int)<#=i.InvokeI("height")#>; }
			set { <#=i.InvokeI("height_set", "(uint)value")#>; }
		}
		public int Count => (int)<#=i.InvokeI("size")#>;
		public int Size => Count;
		public bool IsOrganized => <#=i.InvokeI("isOrganized")#>;
		public <#=csClass#>* Data => (<#=csClass#>*)<#=i.InvokeI("data")#>;

		private VectorOf<#=ClassName#> _points;
		public VectorOf<#=ClassName#> Points => _points;

		private PointCloudOf<#=ClassName#>(IntPtr ptr)
		{
			_ptr = ptr;
			_points = new VectorOf<#=ClassName#>(<#=i.InvokeI("points")#>);
		}

		public PointCloudOf<#=ClassName#>() 
			: this(<#=i.Invoke("ctor")#>)
		{
		}

		public PointCloudOf<#=ClassName#>(int width, int height)
			: this(<#=i.Invoke("ctor_wh", "(uint)width, (uint)height")#>)
		{
		}

		public PointCloudOf<#=ClassName#>(PointCloudOf<#=ClassName#> cloud, Std.VectorOfInt indices)
			:this (<#=i.Invoke("ctor_indices", "cloud.Ptr, indices.Ptr")#>)
		{
		}

		public override ref <#=csClass#> At(int col, int row)
			=>  ref Unsafe.AsRef<<#=csClass#>>(<#=i.InvokeI("at_colrow", "col, row")#>);

		public override void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "&value")#>;

		public override void Dispose()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\PclSharp.Extern\\pointcloud\\PointCloudOf"+ClassName+".generated.h");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"

using namespace pcl;
using namespace std;

typedef vector<<#=cppClass#>, Eigen::aligned_allocator<<#=cppClass#>>> point_vector;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif  

<#= i.Export("cppCloud*", "ctor", "") #>
{
	return new <#=cppCloud#>();
}

<#= i.Export("cppCloud*", "ctor_wh", "uint32_t width, uint32_t height") #>
{
	return new <#=cppCloud#>(width, height);
}

<#=i.Export("cppCloud*", "ctor_indices", "cppCloud* cloud, vector<int>* indices")#>
{
	return new <#=cppCloud#>(*cloud, *indices);
}

<#=i.Export("void", "delete", "cppCloud** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("cppClass*", "at_colrow", "int col, int row")#>
{
	return &ptr->at(col, row);
}

<#=i.ExportI("void", "add", "cppClass* value")#>
{
	//the value needs to be aligned to be pushed into the cloud, so do that.
	<#=cppClass#> deref;
	memcpy(&deref, value, sizeof(<#=cppClass#>));
	ptr->push_back(deref);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("uint32_t", "width", "")#>
{
	return ptr->width;
}

<#=i.ExportI("void", "width_set", "uint32_t width")#>
{
	ptr->width = width;
}

<#=i.ExportI("uint32_t", "height", "")#>
{
	return ptr->height;
}

<#=i.ExportI("void", "height_set", "uint32_t height")#>
{
	ptr->height = height;
}

<#=i.ExportI("int32_t", "isOrganized", "")#>
{
	return ptr->isOrganized();
}

<#=i.ExportI("point_vector*", "points", "")#>
{
	return &ptr->points;
}

<#=i.ExportI("cppClass*", "data", "")#>
{
	return ptr->points.data();
}

#ifdef __cplusplus  
}
#endif  
<#+ i.Dispose(); manager.EndBlock(false); #>
<#+ } #>