<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ", "Normal", "Normal");
	manager.Process(true);
#>
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin, string csout, string cppout)
{ 
	ClassName = cppin + "And" + cppout;
	var classname = ClassName.ToLower();
	var classFunc = "features_normalEstimation_" + classname;
	
	var cppWrapper = "NormalEstimation<"+cppin+", "+cppout+">";

	manager.StartNewFile("NormalEstimationOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
	i.Var("cppout", cppout);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using PclSharp.Search;	

namespace PclSharp.Features
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>
		<#= i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#= i.FuncI("setSearchMethod", "IntPtr tree")#>
		<#= i.FuncI("setIndices", "IntPtr indices")#>
		<#= i.FuncI("compute", "IntPtr cloud")#>

		<#=i.Prop("KSearch", "int")#>
		<#=i.Prop("RadiusSearch", "double")#>
	}

	public class NormalEstimation<#=ClassName#> : Feature<<#=csin#>,<#=csout#>>
	{
		public override int KSearch 
		{ 
			<#=i.InvokeP("KSearch", "int")#> 
		}

        public override double RadiusSearch 
		{ 
			<#=i.InvokeP("RadiusSearch", "int")#> 
		}

		public NormalEstimation<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud) 
			=> <#=i.InvokeI("setInputCloud", "cloud.Ptr")#>;

		public override void SetIndices(VectorOfInt indices)
			=> <#=i.InvokeI("setIndices", "indices")#>;

		public void SetSearchMethod(Search<<#=csin#>> tree)
			=> <#=i.InvokeI("setSearchMethod", "tree.Ptr")#>;

		public override void Compute(PointCloud<<#=csout#>> cloud) 
			=> <#=i.InvokeI("compute", "cloud.Ptr")#>;

		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		protected override void DisposeObject()
			=> <#=i.DeleteI()#>;
	}
}

<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\features\\NormalEstimationOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/features/normal_3d.h>

using namespace pcl;
using namespace std;

typedef <#=cppWrapper#> normal_estimation;
typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;
typedef boost::shared_ptr<vector<int>> boost_indices;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif 

<#=i.Export("normal_estimation*", "ctor", "")#>
{
	return new normal_estimation();
}

<#=i.Export("void", "delete", "normal_estimation** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setSearchMethod", "search::Search<cppin>::Ptr tree")#>
{
	ptr->setSearchMethod(tree);
}

<#= i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{ ptr->setInputCloud(boost_cloud(boost_cloud(), cloud)); }

<#= i.ExportI("void", "setIndices", "std::vector<int>* indices")#>
{ ptr->setIndices(boost_indices(boost_indices(), indices)); }

<#= i.ExportI("void", "compute", "PointCloud<cppout>* cloud")#>
{ ptr->compute(*cloud); }

<#=i.ExportP("KSearch", "int")#>
<#=i.ExportP("RadiusSearch", "double")#>

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); #>
<#+ } #>